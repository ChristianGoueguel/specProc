---
output: github_document
editor_options: 
  markdown: 
    wrap: 72
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "90%",
  out.height = "90%",
  fig.retina = 2
)
```

# specProc

<!-- badges: start -->

[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental)
<!-- badges: end -->

`specProc` package performs a number of pre-processing tasks commonly used in laser-induced breakdown spectroscopy (LIBS). Collectively, these are essential tools in LIBS calibration modeling, called chemometrics. These include:

-   peak analysis
-   Spectral-based normalization 
-   Smoothing and filtering
-   Robust or classical Box-Cox transformation 
-   Pearson or Spearman peaks correlation
-   Descriptive statistics such as mean, standard deviation and higher
    central moments 
-   Statistical tests
-   Rowwise and cellwise outliers detection
-   Robust or classical principal component analysis (PCA)
-   Orthogonal partial-least squares (OPLS)
-   PLS-based wavelength selection


## Installation

You can install the development version from
[GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("ChristianGoueguel/specProc")
```

## Exemples

Loading `specProc` package.

```{r}
library(specProc)
```

```{r echo=FALSE}
devtools::load_all()
```

```{r}
library(tidyverse)
library(patchwork)
```

### Peak analysis

The package peak analysis capabilities include:

-   Baseline removal
-   Peaks detection
-   Fitting single, multiple or overlapping peaks

#### Baseline removal

For instance, when analyzing LIBS spectra, it is often more effective to subtract an estimated baseline from the data. The estimate is constructed by fitting a low-order polynomial function to the spectrum baseline. Then the resulting curve fit result is subtracted from the data.

```{r}
data(specData)
```

```{r message=FALSE, warning=FALSE}
baseline_fit <- specData %>% 
  slice(1L) %>% 
  baselinerm(degree = 7)
```

```{r}
str(baseline_fit, list.len = 5) 
```

```{r}
corrected_spec <- pluck(baseline_fit, "spec")
background <- pluck(baseline_fit, "bkg")
```

```{r include=FALSE}
background <- background %>%
  pivot_longer(
    cols = everything(), 
    names_to = "wavelength",
    values_to = "intensity"
    ) %>%
  modify_at("wavelength", as.numeric)
```

```{r}
plot1 <- specData %>% 
  select(where(is.numeric)) %>%
  slice(1L) %>%
  plotSpec()
```

```{r}
plot2 <- corrected_spec %>% 
  select(where(is.numeric)) %>%
  slice(1L) %>%
  plotSpec()
```

```{r echo=FALSE, fig.height=3, fig.width=6}
plot1 + 
  geom_line(
    data = background, 
    aes(x = wavelength, y = intensity), colour = "red"
    ) +
  ylim(0, 2e3) +
  labs(subtitle = "Before") | 
  plot2 + 
  ylim(0, 2e3) + 
  geom_hline(yintercept = 0, colour = "red") +
  labs(subtitle = "After") |
  plot2 + ylim(0, 50e3) + labs(subtitle = "Zoomed out")
```

#### Peaks detection



#### Peaks fitting

The idea of curve fitting is to find a mathematical model that fits your data. We assume that you have theoretical reasons for picking a function of a certain form. The curve fit finds the specific coefficients (parameters) which make that function match your data as closely as possible. For non-linear least-squares data fitting, Igor uses the Levenberg-Marquardt algorithm to search for the minimum value of chisquare. Chi-square defines a surface in a multidimensional error space. The search process involves starting with an initial guess at the coefficient values. Starting from the initial guesses, Igor searches for the minimum value by travelling down hill from the starting point on the chi-square surface.






